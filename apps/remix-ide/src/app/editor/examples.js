'use strict'

const tileContract = `// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

interface ITileContract {
    function emoji() external view returns (string memory);

    function name() external view returns (string memory);

    function description() external view returns (string memory);

    function extendedAbi() external view returns (string memory);
}

contract StubTileContract is ITileContract {
    function emoji() external pure override returns (string memory) {
        return unicode"ðŸŒƒ";
    }

    function name() external pure override returns (string memory) {
        return "Test Tile";
    }

    function description() external pure override returns (string memory) {
        return "This is a test tile";
    }

    function extendedAbi() external pure virtual override returns (string memory) {
        // Autogenerated - DO NOT EDIT
        return "https://ipfs.io/ipfs/AUTOGEN";
    }
}`

const tileContractTest = `// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;
import "remix_tests.sol"; // this import is automatically injected by Remix.
import "../contracts/TileContract.sol";

contract TileContractTest {
   
    bytes32[] proposalNames;
   
    StubTileContract stubTileContract;
    function beforeAll () public {
        stubTileContract = new StubTileContract();
    }
    
    function checkName () public {
        Assert.greaterThan(int(bytes(stubTileContract.name()).length), int(0), "name is not empty");
    }

    function checkEmoji () public {
        Assert.greaterThan(int(bytes(stubTileContract.emoji()).length), int(0), "emoji is not empty");
        Assert.lesserThan(int(bytes(stubTileContract.emoji()).length), int(10), "emoji is not too long");
    }

    function checkDescription () public {
        Assert.greaterThan(int(bytes(stubTileContract.description()).length), int(0), "description is not empty");
    }
}
`
const deployWithWeb3 = `// Right click on the script name and hit "Run" to execute
(async () => {
    try {
        console.log('Running deployWithWeb3 script...')
        
        const contractName = 'Storage' // Change this for other contract
        const constructorArgs = []    // Put constructor args (if any) here for your contract
    
        // Note that the script needs the ABI which is generated from the compilation artifact.
        // Make sure contract is compiled and artifacts are generated
        const artifactsPath = \`browser/contracts/artifacts/\${contractName}.json\` // Change this for different path

        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))
        const accounts = await web3.eth.getAccounts()
    
        let contract = new web3.eth.Contract(metadata.abi)
    
        contract = contract.deploy({
            data: metadata.data.bytecode.object,
            arguments: constructorArgs
        })
    
        const newContractInstance = await contract.send({
            from: accounts[0],
            gas: 1500000,
            gasPrice: '30000000000'
        })
        console.log('Contract deployed at address: ', newContractInstance.options.address)
    } catch (e) {
        console.log(e.message)
    }
  })()`

const deployWithEthers = `// Right click on the script name and hit "Run" to execute
(async () => {
    try {
        console.log('Running deployWithEthers script...')
    
        const contractName = 'Storage' // Change this for other contract
        const constructorArgs = []    // Put constructor args (if any) here for your contract

        // Note that the script needs the ABI which is generated from the compilation artifact.
        // Make sure contract is compiled and artifacts are generated
        const artifactsPath = \`browser/contracts/artifacts/\${contractName}.json\` // Change this for different path
    
        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))
        // 'web3Provider' is a remix global variable object
        const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner()
    
        let factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer);
    
        let contract = await factory.deploy(...constructorArgs);
    
        console.log('Contract Address: ', contract.address);
    
        // The contract is NOT deployed yet; we must wait until it is mined
        await contract.deployed()
        console.log('Deployment successful.')
    } catch (e) {
        console.log(e.message)
    }
})()`

const readme = `EXAMPLE PROJECT

Remix example project is present when Remix loads for the very first time or there are no files existing in the File Explorer. 
It contains 3 directories:

1. 'contracts': Holds three contracts with different complexity level, denoted with number prefix in file name.
2. 'scripts': Holds two scripts to deploy a contract. It is explained below.
3. 'tests': Contains one test file for 'Ballot' contract with unit tests in Solidity.

SCRIPTS

The 'scripts' folder contains example async/await scripts for deploying the 'Storage' contract.
For the deployment of any other contract, 'contractName' and 'constructorArgs' should be updated (along with other code if required). 
Scripts have full access to the web3.js and ethers.js libraries.

To run a script, right click on file name in the file explorer and click 'Run'. Remember, Solidity file must already be compiled.

Output from script will appear in remix terminal.
`

module.exports = {
  tileContract: { name: 'contracts/TileContract.sol', content: tileContract },
  deployWithWeb3: { name: 'scripts/deploy_web3.js', content: deployWithWeb3 },
  deployWithEthers: { name: 'scripts/deploy_ethers.js', content: deployWithEthers },
  tileContract_test: { name: 'tests/TileContract_test.sol', content: tileContractTest },
  readme: { name: 'README.txt', content: readme }
}
