'use strict'

const tileContract = `// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

interface ITileContract {
    function emoji() external view returns (string memory);

    function name() external view returns (string memory);

    function description() external view returns (string memory);

    function extendedAbi() external view returns (string memory);
}

contract MyTileContract is ITileContract {
    function emoji() external pure override returns (string memory) {
        return unicode"ðŸŒƒ";
    }

    function name() external pure override returns (string memory) {
        return "Test Tile";
    }

    function description() external pure override returns (string memory) {
        return "This is a test tile";
    }

    function extendedAbi() external pure virtual override returns (string memory) {
        // Autogenerated - DO NOT EDIT
        return "https://ipfs.io/ipfs/AUTOGEN";
    }
}`

const tileContractTest = `// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;
import "remix_tests.sol"; // this import is automatically injected by Remix.
import "../contracts/TileContract.sol";

contract MyTileContractTest {
   
    bytes32[] proposalNames;
   
    MyTileContract myTileContract;
    function beforeAll () public {
        myTileContract = new MyTileContract();
    }
    
    function checkName () public {
        Assert.greaterThan(int(bytes(myTileContract.name()).length), int(0), "name is not empty");
    }

    function checkEmoji () public {
        Assert.greaterThan(int(bytes(myTileContract.emoji()).length), int(0), "emoji is not empty");
        Assert.lesserThan(int(bytes(myTileContract.emoji()).length), int(10), "emoji is not too long");
    }

    function checkDescription () public {
        Assert.greaterThan(int(bytes(myTileContract.description()).length), int(0), "description is not empty");
    }
}
`
const deployWithWeb3 = `// Right click on the script name and hit "Run" to execute
(async () => {
    try {
        console.log('Running deployWithWeb3 script...')
        
        const contractName = 'MyTileContract' // Change this for other contract
        const constructorArgs = []    // Put constructor args (if any) here for your contract
    
        // Note that the script needs the ABI which is generated from the compilation artifact.
        // Make sure contract is compiled and artifacts are generated
        const artifactsPath = \`browser/contracts/artifacts/\${contractName}.json\` // Change this for different path

        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))
        const accounts = await web3.eth.getAccounts()
    
        let contract = new web3.eth.Contract(metadata.abi)
    
        contract = contract.deploy({
            data: metadata.data.bytecode.object,
            arguments: constructorArgs
        })
    
        const newContractInstance = await contract.send({
            from: accounts[0],
            gas: 1500000,
            gasPrice: '30000000000'
        })
        console.log('Contract deployed at address: ', newContractInstance.options.address)
    } catch (e) {
        console.log(e.message)
    }
  })()`

const deployWithEthers = `// Right click on the script name and hit "Run" to execute
(async () => {
    try {
        console.log('Running deployWithEthers script...')
    
        const contractName = 'MyTileContract' // Change this for other contract
        const constructorArgs = []    // Put constructor args (if any) here for your contract

        // Note that the script needs the ABI which is generated from the compilation artifact.
        // Make sure contract is compiled and artifacts are generated
        const artifactsPath = \`browser/contracts/artifacts/\${contractName}.json\` // Change this for different path
    
        const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))
        // 'web3Provider' is a remix global variable object
        const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner()
    
        let factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer);
    
        let contract = await factory.deploy(...constructorArgs);
    
        console.log('Contract Address: ', contract.address);
    
        // The contract is NOT deployed yet; we must wait until it is mined
        await contract.deployed()
        console.log('Deployment successful.')
    } catch (e) {
        console.log(e.message)
    }
})()`

module.exports = {
  tileContract: { name: 'contracts/TileContract.sol', content: tileContract },
  deployWithWeb3: { name: 'scripts/deploy_web3.js', content: deployWithWeb3 },
  deployWithEthers: { name: 'scripts/deploy_ethers.js', content: deployWithEthers },
  tileContract_test: { name: 'tests/TileContract_test.sol', content: tileContractTest },
}
